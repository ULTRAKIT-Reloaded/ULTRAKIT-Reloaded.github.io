{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>ULTRAKIT is a BepInEx library for ULTRAKILL that is designed to provide useful extensions and custom content loading capabilities.</p> <p>This wiki will provide resources for developers who wish to use ULTRAKIT in their own addons. If you are not an addon developer but require this mod as a dependency, refer back to the readme for installation.</p> <p>The API heirarchy follows internal namespace heirarchy.</p>"},{"location":"API/extensions/classes/buff/","title":"Buff","text":""},{"location":"API/extensions/classes/buff/#description","title":"Description","text":"<p>An instance class which inherits from IBuff, which can serve as an alternative to making a new class for each buff.</p>"},{"location":"API/extensions/classes/buff/#usage","title":"Usage","text":"<ul> <li>Create a new buff that prints to the log when enabled, prints the enemy's position to the log every active frame, and kills the enemy when disabled. <pre><code>using ULTRAKIT.Extensions.Classes;\nusing ULTRAKIT.Loader.Loaders;\npublic static class BuffCreator\n{\npublic static void Enable()\n{\nDebug.Log(\"Buff enabled!\");\n}\npublic static void Disable()\n{\nbuff.eid.Death();\n}\npublic static void OnUpdate()\n{\nVector3 pos = buff.eid.transform.position;\nDebug.Log(pos);\n}\npublic static void CreateBuff()\n{\nBuff buff = new Buff\n{\nid = \"example.buff\",\nEnableScript = Enable,\nDisableScript = Disable,\nUpdateScript = OnUpdate,\n};\nBuffLoader.RegisterBuff(buff);\n}\n}\n</code></pre></li> </ul>"},{"location":"API/extensions/classes/buff/#properties","title":"Properties","text":"Property Type Description EnableScript Action Function to be called when the buff is enabled. DisableScript Action Function to be called when the buff is disabled. UpdateScript Action Function to be called every frame the buff is active. IsActive bool Whether or not the buff is currently active. id string The unique identifier of the buff. eid EnemyIdentifier The EnemyIdentifier of the enemy this instance is attached to."},{"location":"API/extensions/classes/buff/#additional-information","title":"Additional Information","text":"<p>Alternatively, it is possible (and perhaps preferable) to inherit directly from the IBuff interface. After doing so, it must be registered.</p>"},{"location":"API/extensions/classes/buff/#usage_1","title":"Usage","text":"<ul> <li> <p>Create a new buff that prints to the log when enabled, prints the enemy's position to the log every active frame, and kills the enemy when disabled. <pre><code>using ULTRAKIT.Extensions.Interfaces;\npublic class ExampleBuff : IBuff\n{\npublic EnemyIdentifier eid { get =&gt; _eid; set =&gt; _eid = value; }\npublic bool IsActive { get =&gt; active; }\npublic string id =&gt; \"example.buff\";\nprivate bool active = false;\nprivate EnemyIdentifier _eid;\npublic void Enable()\n{\nactive = true;\nDebug.Log(\"Buff enabled!\");\n}\npublic void Disable() {\nactive = false;\n_eid.Death();\n}\npublic void Update() {\nVector3 pos = _eid.transform.position;\nDebug.Log(pos);\n}\n}\n</code></pre></p> </li> <li> <p>An example of registering a buff: <pre><code>using ULTRAKIT.Extensions.Interfaces;\nusing ULTRAKIT.Loader.Loaders;\npublic static class BuffLoader\n{\npublic static void RegisterBuffs()\n{\nBuffLoader.RegisterBuff(new ExampleBuff());\n}\n}\n</code></pre></p> </li> </ul>"},{"location":"API/extensions/classes/buff/#properties_1","title":"Properties","text":"Property Type Description IsActive bool Whether or not the buff is currently active. id string The unique identifier of the buff. eid EnemyIdentifier The EnemyIdentifier of the enemy this instance is attached to."},{"location":"API/extensions/classes/buff/#methods","title":"Methods","text":"Method Type Description Enable() void Called when the buff is enabled. Disable() void Called when the buff is disabled. Update() void Called every frame the buff is active."},{"location":"API/extensions/classes/cheat/","title":"Cheat","text":""},{"location":"API/extensions/classes/cheat/#description","title":"Description","text":"<p>An instance class which inherits from ICheat, which can serve as an alternative to making a new class for each cheat. It also stores the current active Cheat instance.</p>"},{"location":"API/extensions/classes/cheat/#usage","title":"Usage","text":"<ul> <li>Create a new cheat that prints to the log when enabled, disabled, and active frame. <pre><code>using ULTRAKIT.Extensions.Classes;\npublic static class CheatCreator\n{\npublic static void OnEnable()\n{\nDebug.Log(\"Cheat enabled!\");\n}\npublic static void OnDisable()\n{\nDebug.Log(\"Cheat disabled!\");\n}\npublic static void OnUpdate()\n{\nDebug.Log(\"Cheat is currently active!\");\n}\npublic static void CreateCheat()\n{\nCheat cheat = new Cheat()\n{\nLongName = \"Example Cheat\",\nIdentifier = \"example.cheat\",\nButtonEnabledOverride = \"Cheat Active\",\nButtonDisabledOverride = \"Cheat Inactive\",\nDefaultState = false,\nPersistenceMode = StatePersistenceMode.NotPersistent,\nEnableScript = OnEnable,\nDisableScript = OnDisable,\nUpdateScript = OnUpdate\n};\n// Registers a cheat to the specified category\nCheatsManager.instance.RegisterCheat(cheat, \"Example Mod\");\n}\n}\n</code></pre></li> </ul>"},{"location":"API/extensions/classes/cheat/#properties","title":"Properties","text":"Property Type Description EnableScript Action Function to be called when the cheat is enabled. DisableScript Action Function to be called when the cheat is disabled. UpdateScript Action Function to be called every frame the cheat is active. Instance Cheat The current active cheat instance. IsActive bool Whether or not the cheat is currently active. LongName string The display name of the cheat. Identifier string The unique identifier of the cheat. ButtonEnabledOverride string The text displayed on the cheat button when enabled. ButtonDisabledOverride string The text displayed on the cheat button when disabled. DefaultState bool The default state of the cheat when cheats are enabled. PersistenceMode StatePersistenceMode Whether the cheat should stay enabled/disabled after reload when Keep Cheats Enabled is active. Icon string The key of an icon in the private <code>CheatsManager.Instance.spriteIcons</code> dictionary. This is locked to \"warning\"."},{"location":"API/extensions/classes/cheat/#additional-information","title":"Additional Information","text":"<p>Alternatively, it is possible (and perhaps preferable) to inherit directly from the ICheat interface. After doing so, it must be registered.</p>"},{"location":"API/extensions/classes/cheat/#usage_1","title":"Usage","text":"<ul> <li> <p>Create a new cheat that prints to the log when enabled, disabled, and every active frame. <pre><code>public class ExampleCheat : ICheat\n{\npublic string LongName =&gt; \"Example Cheat\";\npublic string Identifier =&gt; \"example.cheat\";\npublic string ButtonEnabledOverride =&gt; \"Cheat Active\";\npublic string ButtonDisabledOverride =&gt; \"Cheat Inactive\";\npublic bool DefaultState =&gt; false;\npublic bool IsActive =&gt; false;\npublic string Icon =&gt; \"warning\";\npublic StatePersistenceMode PersistenceMode =&gt; StatePersistenceMode.NotPersistent;\npublic void Enable()\n{\nDebug.Log(\"Cheat enabled!\");\n}\npublic void Disable()\n{\nDebug.Log(\"Cheat disabled!\");\n}\npublic void Update()\n{\nDebug.Log(\"Cheat is currently active!\");\n}\n}\n</code></pre></p> </li> <li> <p>An example of registering a cheat <pre><code>public static class CheatsLoader\n{\npublic static void RegisterCheats()\n{\n// Registers a cheat to the specified category\nCheatsManager.instance.RegisterCheat(new ExampleCheat(), \"Example Mod\");\n}\n}\n</code></pre></p> </li> </ul>"},{"location":"API/extensions/classes/cheat/#properties_1","title":"Properties","text":"Property Type Description IsActive bool Whether or not the cheat is currently active. LongName string The display name of the cheat. Identifier string The unique identifier of the cheat. ButtonEnabledOverride string The text displayed on the cheat button when enabled. ButtonDisabledOverride string The text displayed on the cheat button when disabled. DefaultState bool The default state of the cheat when cheats are enabled. PersistenceMode StatePersistenceMode Whether the cheat should stay enabled/disabled after reload when Keep Cheats Enabled is active. Icon string The key of an icon in the private <code>CheatsManager.Instance.spriteIcons</code> dictionary (cloned from the <code>IconManager.Instance.CurrentIcons.cheatIcons</code> dictionary)."},{"location":"API/extensions/classes/cheat/#methods","title":"Methods","text":"Method Type Description Enable() void Called when the cheat is enabled. Disable() void Called when the cheat is disabled. Update() void Called every frame the cheat is active. <p>Valid icons (by default) are:</p> Key Standard Icon PITR Icon \"grid\" \"wall-jumps\" \"navmesh\" \"no-enemies\" \"physics\" \"no-weapon-cooldown\" \"flight\" \"noclip\" \"blind\" \"warning\" \"spawner-arm\" \"save\" \"load\" \"delete\" \"quick-load\" \"teleport\" \"infinite-wall-jumps\" \"infinite-power-ups\" \"invincible-enemies\" \"light\" \"clash\" \"death\""},{"location":"API/extensions/classes/custom-health-bar/","title":"Custom Health Bar (Monobehaviour)","text":""},{"location":"API/extensions/classes/custom-health-bar/#description","title":"Description","text":"<p>Converts the health bar of an enemy from a screen overlay to a hovering-over-the-head type to prevent blinding the player. May need to be adjusted.</p> <p>Note: This adjusts the pre-existing health bar, not replaces the script entirely.</p>"},{"location":"API/extensions/classes/render-fixer/","title":"Render Fixer (Monobehaviour)","text":""},{"location":"API/extensions/classes/render-fixer/#description","title":"Description","text":"<p>When placed on an object loaded from an asset bundle, it will set all child renderer layers and refresh the applied shaders, which can fix rendering issues.</p>"},{"location":"API/extensions/classes/render-fixer/#usage","title":"Usage","text":"<pre><code>gameObject.AddComponent&lt;RenderFixer&gt;().Layer = LayerNumber;\n</code></pre>"},{"location":"API/extensions/classes/uksetting/","title":"UKSetting","text":""},{"location":"API/extensions/classes/uksetting/#description","title":"Description","text":"<p>An instance class that contains core attributes of each type of custom settings option.</p>"},{"location":"modules/1-core/","title":"Core","text":"<p>The core module controls the internal initialization of ULTRAKIT Reloaded.</p>"},{"location":"modules/2-data/","title":"Data","text":"<p>The data module contains definitions for custom content types and is required to work with them in the Unity Editor.</p>"},{"location":"modules/3-editor/","title":"Editor","text":"<p>The editor module adds a new section to the Unity Editor to create custom object assets and export them.</p>"},{"location":"modules/4-extensions/","title":"Extensions","text":"<p>The extensions module contains all new functions and tools apart from those used to load custom assets.</p>"},{"location":"modules/5-loader/","title":"Loader","text":"<p>The loader module loads, registers, and injects custom content into the game.</p>"}]}